snippet Geo
template <typename T> struct Point {
	T x, y;

	Point() : x(0), y(0) {}

	Point(T _x, T _y) : x(_x), y(_y) {}

	Point operator+(const Point other) const {
		return Point(x + other.x, y + other.y);
	}

	Point operator-(const Point other) const {
		return Point(x - other.x, y - other.y);
	}

	Point operator*(const T lambda) const {
		return Point(x * lambda, y * lambda);
	}

	Point operator/(const T lambda) const {
		return Point(x / lambda, y / lambda);
	}

	bool operator<(const Point &other) const {
		return tie(x, y) < tie(other.x, other.y);
	}
	bool operator==(const Point &other) const {
		return tie(x, y) == tie(other.x, other.y);
	}
	bool operator>(const Point &other) const { return other < *this; }
	bool operator!=(const Point &other) const { return !(*this == other); }
	bool operator<=(const Point &other) const { return !(other < *this); }
	bool operator>=(const Point &other) const { return other <= *this; }

	friend ostream &operator<<(ostream &out, const Point &a) {
		return out << a.x << " " << a.y;
	}
	friend istream &operator>>(istream &in, Point &a) { return in >> a.x >> a.y; }
	friend T dot(const Point a, const Point b) { return a.x * b.x + a.y * b.y; }

	friend T cross(const Point a, const Point b) { return a.x * b.y - a.y * b.x; }

	friend T dis2(const Point a, const Point b) { return dot(b - a, b - a); }
};

endsnippet

snippet ConvexHull
// Sorts points by increasing coordinates (x then y) and returns indices of
// extremal points of convex hull Replace >= by > to have all points on boundary
// and not only extremal ones
template <typename T> vector<int> cvxHull(vector<Point<T>> &points) {
	sort(points.begin(), points.end());
	vector<int> upper;
	int szUpper = 0;
	int nbPoints = points.size();
	for (int iPoint = 0; iPoint < nbPoints; ++iPoint) {

		while (szUpper >= 2 and
				cross(points[upper[szUpper - 1]] - points[upper[szUpper - 2]],
					points[iPoint] - points[upper[szUpper - 2]]) <= 0)
			// change <= to < to add boundary points
			--szUpper, upper.pop_back();
		szUpper++;
		upper.push_back(iPoint);
	}
	vector<int> lower;
	int szLower = 0;
	for (int iPoint = nbPoints - 1; iPoint >= 0; --iPoint) {
		while (szLower >= 2 and
				cross(points[lower[szLower - 1]] - points[lower[szLower - 2]],
					points[iPoint] - points[lower[szLower - 2]]) <= 0)
			// change <= to < to add boundary points
			--szLower, lower.pop_back();
		szLower++;
		lower.push_back(iPoint);
	}
	for (int i = 1; i < szLower - 1; ++i)
		upper.push_back(lower[i]);
	return upper;
}
endsnippet

snippet HalfPlane
const double EPS = 1e-9;
const double DINF = 1e100;
template <typename T> struct HalfPlane {
	Point<T> p, pq;
	T angle;
	HalfPlane() {}
	HalfPlane(Point<T> _p, Point<T> _q)
		: p(_p), pq(_q - _p), angle(atan2(pq.y, pq.x)) {}
	bool operator<(HalfPlane &b) const { return angle < b.angle; }
	bool out(Point<T> q) { return cross(pq, q - p) < EPS; }

	Point<T> intersect(HalfPlane<T> l) {
		if (abs(cross(pq, l.pq)) < EPS)
			return Point<T>(DINF, DINF);
		return l.p + l.pq * (cross(p - l.p, pq) / cross(l.pq, pq));
	}
};
// Halfplane to the left of line

template <typename T> vector<Point<T>> intersect(vector<HalfPlane<T>> b) {
	vector<Point<T>> bx = {
		{DINF, DINF}, {-DINF, DINF}, {-DINF, -DINF}, {DINF, -DINF}};
	for (int i = 0; i < 4; ++i)
		b.emplace_back(bx[i], bx[(i + 1) % 4]);
	sort(b.begin(), b.end());

	int n = b.size(), q = 1, h = 0;
	vector<HalfPlane<T>> c(b.size() + 10);
	for (int i = 0; i < n; ++i) {
		while (q < h and b[i].out(c[h].intersect(c[h - 1])))
			h--;
		while (q < h and b[i].out(c[q].intersect(c[q + 1])))
			q++;
		c[++h] = b[i];
		if (q < h and abs(cross(c[h].pq, c[h - 1].pq)) < EPS) {
			if (dot(c[h].pq, c[h - 1].pq) <= 0)
				return {};
			h--;
			if (b[i].out(c[h].p))
				c[h] = b[i];
		}
	}
	while (q < h - 1 and c[q].out(c[h].intersect(c[h - 1])))
		h--;
	while (q < h - 1 and c[h].out(c[q].intersect(c[q + 1])))
		q++;
	if (h - q <= 1)
		return {};
	c[h + 1] = c[q];
	vector<Point<T>> s;
	for (int i = q; i < h + 1; ++i)
		s.push_back(c[i].intersect(c[i + 1]));
	return s;
}
endsnippet
